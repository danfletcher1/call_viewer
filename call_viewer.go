/*

This package is missing modules. You can read the work and make your own working version

The object is to read a stream from kafka, the stream is kvp from Radius protocol 

Then we can provider a html table in a browser of the call in progreass by using start/interrim/stop records generated by radius accounting.

*/


package main

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"os"
	"os/signal"
	webskt "github.com/danfletcher1/pkg_websocket" 
	"strings"
	"time"
)

type kafkaMessage struct {
	Headers   string // Data Headers where available
	Data      string // The data payload
}

// Running Variables
var conf = make(map[string]string)
var receiveChannel = make(chan []byte, 10)

// These are termination flags to help end the program cleanly
var Terminate = false
var Running = false

func main() {

	//
	// Initial setup
	//

	conf["kafkaTopic"] = ""
	conf["kafkaHost"] = ""
	conf["logLevel"] = "3"
	conf["debug"] = "true"
	conf["stdLog"] = ""
	conf["stdError"] = ""

	// Connect to kafka
	err := kafka.Connect(conf["kafkaHost"])
	if err != nil {
		fmt.Println(err)
	}

	go func() {
		kafka.Receive(conf["kafkaTopic"], receiveChannel)
		if err != nil {
			fmt.Println(err)
		}
	}()

	// Open the two log files
	err = logfile.Open(conf["stdLog"], conf["stdError"])
	if err != nil {
		fmt.Println("I have a problem opening log files, but will continue", err)
	}
	defer logfile.Close()

	// Start Websocket Listener
	go webskt.Init()

	//
	// Main function
	//

	go func() {
	Loop:

		for {
			switch Terminate {

			case false:
				Running = true

				// Check for new messages
				readData(<-receiveChannel)
				Running = false
			case true:
				break Loop
			}
		}
	}()

	//
	// Termination Loop
	//

	signals := make(chan os.Signal, 1)
	signal.Notify(signals, os.Interrupt)
	<-signals
  
	// Tell all loops to terminate
	Terminate = true
	crt("Termination Received, Terminating Nicely - Max 10s")

	for x := 0; x < 1; x++ {
		time.Sleep(time.Second * 1)
		if Running == false {
			log("Clean Exit")
			os.Exit(0)
		}
	}
  
	fmt.Println("Timeout Reached Dirty Exit")
	crt("Timeout Reached Dirty Exit")
}

// Read JSON from kafka message
func readData(jsonByte []byte) {

  // Unmarshal json to struct
	newmsg := kafkaMessage{}
	err := json.Unmarshal(jsonByte, &newmsg)
	if err != nil {
		fmt.Println(err)
	}
  
  // Restore out radius kvp message
	values := make(map[int][]byte)
	for i, v := range strings.Split(newmsg.Data, ",") {
		data, _ := base64.StdEncoding.DecodeString(v)
		values[i] = data
	}

  // decoding of key radius values we are interested in
	var CallingStationId, CalledStationId, AccSessionId, IngressLocalIP, IngressRemoteIP, EgressLocalIP, EgressRemoteIP []byte
	for i, v := range strings.Split(newmsg.Headers, ",") {
		if v == "31" {
			CallingStationId = values[i]
		}
		if v == "30" {
			CalledStationId = values[i]
		}
		if v == "44" {
			AccSessionId = values[i]
		}
		if v == "26/9148/74" {
			IngressLocalIP = values[i]
		}
		if v == "26/9148/75" {
			IngressRemoteIP = values[i]
		}
		if v == "26/9148/76" {
			EgressLocalIP = values[i]
		}
		if v == "26/9148/77" {
			EgressRemoteIP = values[i]
		}
	}

	fmt.Println(newmsg.From, newmsg.DataDef, string(CallingStationId), ">>", string(CalledStationId))
	fmt.Println(string(IngressLocalIP)+"("+string(EgressLocalIP)+")", string(IngressRemoteIP)+"("+string(EgressRemoteIP)+")")

  // Send a websocket message with the important kvp
	var sendMessage = webskt.WebsocketMessage{
		Event:  string(newmsg.DataDef),
		Data:   string(CallingStationId) + " >> " + string(CalledStationId),
		Param1: string(IngressLocalIP) + " (" + string(EgressLocalIP) + ")",
		Param2: string(IngressRemoteIP) + " (" + string(EgressRemoteIP) + ")",
		Param3: string(newmsg.From),
		Param4: string(AccSessionId),
		Param5: "",
		Param6: "",
	}

	for _, ws := range webskt.ListenFor {
		webskt.Send(sendMessage, ws)
	}
}

// log is verbose log
func log(msg string) {
	if conf["logLevel"] == "3" {
		logfile.Log("LOG:" + msg)
		//msgbus.Log(msg)
	}
	if conf["debug"] == "true" {
		fmt.Println("LOG:", msg)
	}
}

// war is warning errors that will retry
func war(msg string) {
	if conf["logLevel"] == "3" || conf["logLevel"] == "2" {
		logfile.Log("WAR:" + msg)
		//msgbus.War(msg)
	}
	if conf["debug"] == "true" {
		fmt.Println("WAR:", msg)
	}
}

// err is critical errors will not retry, and probably need manual intervention
func crt(msg string) {
	if conf["logLevel"] == "3" || conf["logLevel"] == "2" || conf["logLevel"] == "1" {
		logfile.Err("ERR:" + msg)
		//msgbus.Err(msg)
	}
	if conf["debug"] == "true" {
		fmt.Println("ERR:", msg)
	}
}
